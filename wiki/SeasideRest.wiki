#summary Provides a short overview over Seaside-REST.

= Introduction =

Seaside-REST allows you to easily dispatch to methods based on several properties of an HTTP request. Think of pattern matching in functional programming languages for an HTTP request. This can be used to write RESTful web application.


= Details =

You start by sublassing either {{{WARestfulFilter}}} or {{{WARestfulHandler}}} and putting methods there. There are several request properties that you can dispatch on:

== HTTP Method ==
Every method must have a pragma that indicates the HTTP method on which it should be invoked.
{{{
simpleGet
   <GET>
}}}
{{{
simplePost
   <POST>
}}}

== Request URL path ==
You can mark method to be executed only on a certain request path and bind it to method arguments.
{{{
getEmptyPath
    "will be executed if the request path is empty"
    <GET>
}}}
{{{
getFirstPathElement: pathElement
    "Will be executed if the request path is one element long, the path element will be bound to the first method argument.
    Eg. if the request is for '/index.html' the value of pathElement will be 'index.html'"
    <GET>
}}}
{{{
getFirstPathElement: firstPathElement secondPathElement: secondPathElement
    "Will be executed if the request path is two elements long, the first path element will be bound to the first method argument, the second path element will be bound to the second method argument. "
    <GET>
}}}
You can use the {{{Path:}}} pragma to get more control over when the method should be invoked. 

== Query Arguments ==

== Conent-Type ==
You can mark methods as to be invoked only on certain content types. This only makes sense for HTTP methods that have a request body like POST and PUT.
{{{
urlEncodedPost
    <POST>
    <Consumes: 'application/x-www-form-urlencoded'>
}}}

== Accept ==
You can mark methods as to be invoked when the client accepts the response content type.
{{{
getPng
    <GET>
    <Produces: 'image/png'>
}}}

== Conflict Resolution ==